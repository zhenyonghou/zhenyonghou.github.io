---
layout: post
date:   2012-08-11 23:49
categories: c++
---

两年前尝试读过sgi STL源码，后来发现闷头读源码不如买本《STL源码解析》效果好。几个月前从网上下载了《Effective STL》的电子书，这是本11年前出版的价值很高的书，还是在业余时间读了两遍，受益良多。

下面粗略地记了些阅读笔记，只记录了部分条款。

条款1：仔细选择你的容器

vector,list,deque之间的选择：
vector是一种可以默认使用的序列类型；
当很频繁地对序列中部进行插入和删除时应该用list；
当大部分插入和删除发生在序列的头或尾时可以选择deque这种数据结构。

容器的选择，下面几点尤为重要：
你需要“可以在容器的任意位置插入一个新元素”的能力吗？如果是，你需要序列容器，关联容器做不到。
你关心元素在容器中的顺序吗？如果不，散列容器就是可行的选择。否则，你要避免使用散列容器。
当插入或者删除数据时，是否非常在意容器内现有元素的移动？如果是，你就必须放弃连续内存容器。
查找速度很重要吗？如果是，你就应该看看散列容器（参见条款25），排序的vector（参见条款23）和标准的关联容器——大概是这个顺序。
条款3：使容器里对象的拷贝操作轻量而正确

一个使拷贝更高效、正确的方式是建立指针的容器而不是对象的容器，为避免指针带来的一系列问题，可用shared_ptr。
条款4：用empty来代替检查size()是否为0

条款5：尽量使用区间成员函数代替它们的单元素兄弟

如：用vector的assign成员代替手写循环。
条款7：当使用new得指针的容器时，记得在销毁容器前delete那些指针。

条款9：在删除选项中仔细选择

去除一个容器中有特定值的所有对象：
如果容器是vector、string或deque，使用erase-remove惯用法。
如果容器是list，使用list::remove。
如果容器是标准关联容器，使用它的erase成员函数。

去除一个容器中满足一个特定判定式的所有对象：
如果容器是vector、string或deque，使用erase-remove_if惯用法。
如果容器是list，使用list::remove_if。
如果容器是标准关联容器，使用remove_copy_if和swap，或写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。

在循环内做某些事情（除了删除对象之外）：
如果容器是标准序列容器，写一个循环来遍历容器元素，每当调用erase时记得都用它的返回值更新你的迭代器。
如果容器是标准关联容器，写一个循环来遍历容器元素，当你把迭代器传给erase时记得后置递增它。
条款20：为指针的关联容器指定比较类型 

条款21: 永远让比较函数对相等的值返回false
条款24：当关乎效率时应该在map::operator[]和map-insert之间仔细选择
参考我的另一篇文章。

条款37：用accumulate或for_each来统计区间

条款43：尽量用算法调用代替手写循环

条款46：考虑使用函数对象代替函数作算法的参数

我的这篇文章里有使用函数对象和函数的优劣比较。



作者 [侯振永][1]     
写于2012 年 8月 11日

[1]: https://zhenyonghou.github.io/